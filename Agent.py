import numpy as np

class stupidAgent():
    def __init__(self, stepLimit:int, number_of_bandits:int, epsilon:float, UCB_constant:float) -> None:
        self.stepLimit = stepLimit
        self.curr_step = 0
        self.num_of_bandit = number_of_bandits
        self.epsilon = epsilon
        self.UCB_constant = UCB_constant
        self.actionVaule = np.zeros(number_of_bandits)
        self.actionVaule_history = []
        self.actionCount = np.zeros(number_of_bandits)
        self.bestAction = np.random.randint(number_of_bandits, size=1)  #initial action
    
    # def learningLoop(self, method:str):
    #     while self.curr_step < self.stepLimit:
            
    #         match method:
    #             case "greedy":
    #                 selected_action = self.epsilon_greedy(self.epsilon)
    #             case "UCB":
    #                 pass
    #         self.update()    
    #     pass
    
    def update(self, action:int, reward:float) -> None:
        self.curr_step += 1
        self.actionCount[action] += 1.0
        self.actionVaule[action] = self.actionVaule[action] + (reward - self.actionVaule[action])/self.actionCount[action]
        pass
    
    def epsilon_greedy(self, epsilon:float) -> int:
        decision = np.random.rand()
        if decision <= epsilon:
            selected_action = np.random.randint(self.num_of_bandit, size=1)
        else:
            max_vaule = max(self.actionVaule)
            max_ind = []
            for i in range(self.num_of_bandit):
                if self.actionVaule[i] == max_vaule:
                    max_ind.append(i)
            selected_action = np.random.choice(max_ind)
            self.bestAction = selected_action
        return selected_action
    
    def action_selection(self, method:str)->int:
        match method:
            case "greedy":
                selected_action = self.epsilon_greedy(self.epsilon)
            case "UCB":
                pass
        return selected_action
            
           
        